
#include <vector>
#include <memory>
#include <map>
#include <functional>
#include <cmath>
#include <iostream>
#include <string>
#include <utility>
#include <iterator> 
#include <regex>
#include <cmath>

template <typename T>
void MyPrint(const T &value){
    std::cout << value << '\n';
}

template <typename T, typename... Args>
void MyPrint(const T &value, const Args &... args ){
    std::cout << value << ' ';
    MyPrint(args...);
}


int main()
{

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 1. Регулярные выражения


	// 1a Обеспечить прием от пользователя целых значений в десятичной форме.
	// Необходимо учесть специфику пользователя, который должен ввести целое,
	//				а может ввести все, что угодно,
	//				число может предворяться знаком -/+,
	//				количество цифр может быть любым (в частности может превышать sizeof(int))
	//				
	//Подсказки:
	//			a) std::string может принять строчку с любым содержимым
	//			б) нужно проанализировать, соответствует ли введенное значение целому в допустимом диапазоне
	//			в) и, если соответствует, перевести из строкового представления в значение типа int
	//					(для преобразования удобно использовать С++11 - std::stoi())

	{

	}
	// 1b ООбеспечить прием от пользователя целых значений в шестнадцатеричной форме.
	{

	}


	// 1с Обеспечить прием от пользователя плавающих значений в форматах
	//      -2.33 или +1.23e+06 или 0.245E10
	{

	}

	// 1d Требуется узнать - есть ли хотя бы одна десятичная цифра в строке
	{
	

	}

	
	//1e Требуется найти все десятичные цифры в строке
	{


	}
	////////////////////////////////////////////////////////////////////////////////
	//Задание 2 variadic template - функция
	//Реализуйте функцию, которая умеет печатать любое количество параметров любого типа,
	//Например: MyPrint(4,8.8, A(1),std::string("dfg") );


	{
        MyPrint(4,8.8,std::string("dfg"));
	}

	////////////////////////////////////////////////////////////////////////////////
	//Задание 3 function
	//3a Реализуйте "калькулятор", который будет выполнять простейшие действия: +,-,*,/,^
	//     над операндами типа double:
	// '+' - посредством шаблона глобальной функции
	// '-' - посредством шаблона std::minus 
	// '*' - посредством функционального объекта 
	// '/' - посредством лямбда-функции
	// '^' - посредством функции pow() (перегруженный вариант для double)
	// '%' - дробную часть от результата плавающего деления посредством std::bind()
	//* '?' - наибольшее из двух значений посредством std::bind() и метода Вашего класса  
	// 
	//Для хранения значка операции и соответствующего ему действия логично использовать
	//std::map<char, ???> 
	{


	}


	//3б Рекурсивная лямбда функция. Посредством std::function и лямбда функции реализуйте
	//вычисление суммы натурального ряда (x+(x-1)+ (x-2)+...+1).
	//Подсказка: так как существование любой переменной начинается с момента определения, 
	//например: int x=x; - бессмысленно, но корректно
	// => переменную типа function можно использовать в списке захвата  - ... f = [&f]...
	{
		
	}

	//////////////////////////////////////////////////////////////////////////////////
	//Задание 4 std::tuple
	//Создайте класс book (автор, заглавие, год издания...). 
	//Создайте библиотеку таким образом, чтобы книги хранились в упорядоченном виде.
	//Чтобы упорядочить совокупность книжек, нужно сформировать условие сравнения, то есть
	//перегрузить, например operator<. При реализации оператора хочется сформировать условие
	//с учетом всех данных!!! 
	
	//Подсказка: Для упорядочения удобно использовать шаблон std::tuple,
	//так как для std::tuple перегружены операторы ==,!=,<,<=,>,>=
	//,которые сравнивают два кортежа лексиграфически (в порядке следования членов).
	

	//Для проверки распечатайте библиотеку

	{


	}

/////////////////////////////////////////////////////////////////
	//Задание 5. shared_ptr и weak_ptr
	//Создаем генеалогическое дерево посредством класса human. В классе хранятся:
	//имя - string
	//возможно признак: жив или уже нет...
	//родители - shared_ptr (родители не всегда известны...)
	//дети - контейнер из weak_ptr (чтобы избежать циклических зависимостей)

	//Методы класса human:
	//конструктор - для инициализации имени и признака
	//конструктор копирования, оператор присваивания, move ???
	//статический метод child() - 
	//				должен создать создать и вернуть обертку для родившегося человека
	//				+ сформировать все связи ребенка с родителями и наоборот

	//Ввести возможность распечатать генеалогическое дерево для указанного индивидума

	{
		//История должна с кого-то начинаться => "Жили-были дед да баба, например, Адам и Ева"
		//(то есть на самом деле два деда и две бабы):


		//std::shared_ptr<human> grandM1(new human("Eva"));
		//...
	
		//у них появились дети - child():


		//а у детей в свою очередь свои дети:


		//...

	}


}

